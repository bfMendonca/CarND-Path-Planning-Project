## Model Documentation

This file countains an brief description of the method that was used in order to acquire an valid software that is able to drive trhough the high scenario

## State machine

In order to control the behaviour of the vehicle properly through the scenario, the code was divided into the following classes:

### CarState

This class is written inside the "path_planner.h", line 25. It is just a struct that will represent a car's state. It will be used for the ego vehicle and the other vehicles at the highway

### Path

This structure is defined at "path_planner.h", at line 60. It is a represetation of a trajectory that the vehicle could follow. It also has a convinece method, "fromJSON", line 61, that converts from the JSON format, recevied from simulator. 

###  PathPlanner

This class is responsible for calculating a path that the vehicle should follow. As the map high map is known, when created, the highway map is stored as a const reference inside these class variables map_x, map_y and map_s. Those variables will be used at the path generation proccess to convert to and from the Frenet Coordinate system. 

The path generation proccess was written inside the "generatePath" method. It receives the current CarState, the last Path, returned by the simulator, the target path lateral distance, in frenet coordinate system, the target speed and an reference Path, newPath, in which the output will be written. This method will return true if was able to generate a valid path and false, otherwise.

Some additional helper functions were written to the "helpers.h" file, specifically the "toLocalFrame", at line 165 and "fromLocalFrame", line 178, that are used for conversion of a pose from the "world" euclidean reference frame to the "vehicle's" euclidean reference frame. 

The generation proccess was heavily based on the presented at the Questions and Answers class. The first proccess done was to convert the two last points of the previous path to the local reference, lines 64 and 65 of path_planner.cpp. For the first iteration, were the "lastPath" would not contain those points, the vehicle position and heading were used based at the supposition that the generated path should be the start of the new generated path. Those pose were added to the vectors refPtsX and refPtsY, in which the anchor points for the new path would be added. 

Following the first points from the previous path, the next anchor points were generated using the "Frenet" coordinate system. Those points were evenly spaced with the displacement between them defined by the "sameLameRefDInc" variable and the "distance" from center given by "targetD", which is a input for the generatePath method and describes for which "distance", or lane, we would like to generate the new path to. After generating the anchor points in the "Frenet frame", they were converted back to Euclidean coordinates using the helper function "getXY" and then changed to the vehicle frame of reference

The anchor points describe roughly the desired position for the vehicle at for each "sameLameRefDInc" ahead. From those points the "spline" interpolant method was used to generate a smooth trajectory that the vehicle is capable of following. This procedure is written from line 105 thourgh line 139 of "path_planner.cpp".

A desired speed was used in order to correctly set the spacing between the points generated by the spline interpolant.


### BehavioralSMachine

This "State machine" controls the behavior of the vehicle during the highway driving. It's written in the files "behavioral_smachine.cpp" and "behavioral_smachine.h". The states for this machine are "Keep Lane", "Prepare for Lane change" and "Change Lane", described at the enum "States", "behavioral_smachine.h" line 13.

For each iteration of the code the method "update" was called inside the "main.cpp" and a new Path returned as output. The current machine state is used in order to properly call the "generatePath", described above, with the proper inputs that would generate a suitable path. 

As additional "helper" functions used, the "getCarsAtLane" method returns a vector of the cars at the lane specified for the input "int laneId". This is mainly used in order to "split" the cars for which lane they belong. The "getNextCarInLane" returns the next car ahead of the ego vehicle for a given lane id. In order to best decide which lane to switch to, if needed, the method "getLaneChangeCost" outputs an "score" for a given lane. This scores goes from 0 to 100, being 0 a "poor" choice for lane change and "100" a good. It alsos returns -1 as score if the lane change can not be executed for the given time. 

Finally, in order to proper navigate through the environment, an speed controller was written in order to control the ego car's speed. If there are no cars ahead, it will accelerate untilt the MAX_SPEED, line 66, is reached, otherwise, it implements a simple "PD" controller wich will try to match the the speed of the vehicle ahead and maintain the distance defined by the "DESIRED_FOLLOWING_DISTANCE" constant, line 85.

The "Keep Lane" state, method "klState(...)" will constantly verify the distance for the next vehicle and, when this value is smaller than "DISTANCE_TO_LANE_CHANGE", line 71, it will call the method "getLaneChangeCost" to verify which of the lateral lanes, if any, gives a better choice for lane changing. The lane with the higher score will be choose for "lane change" and the State Machine will then transit 
to the "Prepare lane change" state, method "plcState(...)". 

At the "PLC" state, the state machine will still plan to the current lane but, in addition, will generate a proposal path to lane change for the target desired lane. If a "valid" proposal path is found, then the state machine will transit to the lane change state "LC", method "lcState(...)" in which the generatePath is used with the target lane distance value and this lane changing path is return as the state machine output. Once the vehicle finished the lane changing behaviour, the state machine goes back to "keep lane" state. 




